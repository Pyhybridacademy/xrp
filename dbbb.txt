main app

from django.db import models
from django.contrib.auth.models import User
from django.db.models.signals import post_save
from django.dispatch import receiver
from decimal import Decimal
from django.utils import timezone
import logging

# Set up logging
logger = logging.getLogger(__name__)

class InvestmentPlan(models.Model):
    PLAN_TYPES = (
        ('standard', 'Standard'),
        ('premium', 'Premium'),
        ('vip', 'VIP'),
        ('platinum', 'Platinum'),
        ('gold', 'Gold'),
    )
    
    name = models.CharField(max_length=50, choices=PLAN_TYPES)
    min_deposit = models.DecimalField(max_digits=15, decimal_places=2)
    max_deposit = models.DecimalField(max_digits=15, decimal_places=2)
    roi_percentage = models.DecimalField(max_digits=5, decimal_places=2)
    duration_days = models.IntegerField()
    description = models.TextField(blank=True)
    is_active = models.BooleanField(default=True)
    
    def __str__(self):
        return f"{self.get_name_display()} Plan ({self.min_deposit} - {self.max_deposit})"

class Cryptocurrency(models.Model):
    name = models.CharField(max_length=50)
    symbol = models.CharField(max_length=10)
    wallet_address = models.CharField(max_length=100)
    logo = models.ImageField(upload_to='crypto_logos/', null=True, blank=True)
    is_active = models.BooleanField(default=True)
    
    def __str__(self):
        return f"{self.name} ({self.symbol})"
    
    class Meta:
        verbose_name_plural = "Cryptocurrencies"

class WalletAddress(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='wallet_addresses')
    cryptocurrency = models.ForeignKey('Cryptocurrency', on_delete=models.CASCADE)
    address = models.CharField(max_length=100)
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"{self.user.username}'s {self.cryptocurrency.name} Wallet"

class UserProfile(models.Model):
    CURRENCY_CHOICES = (
        ('USD', 'US Dollar ($)'),
        ('EUR', 'Euro (€)'),
        ('GBP', 'British Pound (£)'),
        ('NGN', 'Nigerian Naira (₦)'),
        ('GHS', 'Ghanaian Cedi (₵)'),
        ('KES', 'Kenyan Shilling (KSh)'),
        ('ZAR', 'South African Rand (R)'),
        ('AUD', 'Australian Dollar (A$)'),
        ('CAD', 'Canadian Dollar (C$)'),
        ('JPY', 'Japanese Yen (¥)'),
        ('CNY', 'Chinese Yuan (¥)'),
        ('INR', 'Indian Rupee (₹)'),
        ('KRW', 'South Korean Won (₩)'),
        ('SGD', 'Singapore Dollar (S$)'),
        ('HKD', 'Hong Kong Dollar (HK$)'),
        ('MYR', 'Malaysian Ringgit (RM)'),
        ('THB', 'Thai Baht (฿)'),
        ('PHP', 'Philippine Peso (₱)'),
        ('IDR', 'Indonesian Rupiah (Rp)'),
    )

    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='profile')
    full_name = models.CharField(max_length=100, blank=True)
    phone = models.CharField(max_length=20, blank=True)
    country = models.CharField(max_length=50, blank=True)
    currency = models.CharField(max_length=3, choices=CURRENCY_CHOICES, default='USD')
    balance = models.DecimalField(max_digits=15, decimal_places=2, default=0)
    profit = models.DecimalField(max_digits=15, decimal_places=2, default=0)
    bonus = models.DecimalField(max_digits=15, decimal_places=2, default=0)
    investment = models.DecimalField(max_digits=15, decimal_places=2, default=0)
    preferred_cryptocurrency = models.ForeignKey('Cryptocurrency', on_delete=models.SET_NULL, null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    def __str__(self):
        return f"{self.user.username}'s Profile"

@receiver(post_save, sender=User)
def manage_user_profile(sender, instance, created, **kwargs):
    if created:
        UserProfile.objects.create(user=instance)
    else:
        try:
            instance.profile.save()
        except UserProfile.DoesNotExist:
            UserProfile.objects.create(user=instance)

class KYCVerification(models.Model):
    ID_TYPES = (
        ('passport', 'Passport'),
        ('drivers_license', 'Driver\'s License'),
        ('national_id', 'National ID'),
    )
    
    STATUS_CHOICES = (
        ('submitted', 'Submitted'),
        ('approved', 'Approved'),
        ('rejected', 'Rejected'),
    )
    
    user = models.OneToOneField(User, on_delete=models.CASCADE)
    id_type = models.CharField(max_length=20, choices=ID_TYPES)
    id_number = models.CharField(max_length=50)
    id_front = models.ImageField(upload_to='kyc_documents/', null=True)
    id_back = models.ImageField(upload_to='kyc_documents/', null=True)
    selfie = models.ImageField(upload_to='kyc_documents/', null=True)
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='submitted')
    rejection_reason = models.TextField(blank=True, null=True)
    submitted_at = models.DateTimeField(auto_now_add=True)
    verified_at = models.DateTimeField(null=True, blank=True)
    
    def __str__(self):
        return f"{self.user.username}'s KYC Verification"

class Transaction(models.Model):
    TRANSACTION_TYPES = (
        ('deposit', 'Deposit'),
        ('withdrawal', 'Withdrawal'),
        ('investment', 'Investment'),
        ('profit', 'Profit Payment'),
        ('bonus', 'Bonus Payment'),
    )
    
    STATUS_CHOICES = (
        ('pending', 'Pending'),
        ('completed', 'Completed'),
        ('rejected', 'Rejected'),
    )
    
    PAYMENT_METHODS = (
        ('bank_transfer', 'Bank Transfer'),
        ('credit_card', 'Credit Card'),
        ('crypto', 'Cryptocurrency'),
        ('internal', 'Internal Transfer'),
    )
    
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    transaction_type = models.CharField(max_length=20, choices=TRANSACTION_TYPES)
    amount = models.DecimalField(max_digits=15, decimal_places=2)
    payment_method = models.CharField(max_length=20, choices=PAYMENT_METHODS, blank=True)
    cryptocurrency = models.ForeignKey('Cryptocurrency', on_delete=models.SET_NULL, null=True, blank=True)
    wallet_address = models.CharField(max_length=100, blank=True, null=True)
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending')
    created_at = models.DateTimeField(auto_now_add=True)
    payment_proof = models.ImageField(upload_to='payment_proofs/', null=True, blank=True)
    completed_at = models.DateTimeField(null=True, blank=True)
    
    def __str__(self):
        return f"{self.user.username}'s {self.get_transaction_type_display()} - {self.amount}"
    
    def save(self, *args, **kwargs):
        is_newly_completed = False
        if self.pk:
            try:
                old_transaction = Transaction.objects.get(pk=self.pk)
                if old_transaction.status != 'completed' and self.status == 'completed':
                    is_newly_completed = True
                    self.completed_at = timezone.now()
            except Transaction.DoesNotExist:
                pass
        elif self.status == 'completed':
            is_newly_completed = True
            self.completed_at = timezone.now()
        
        super().save(*args, **kwargs)
        
        if is_newly_completed:
            logger.info(f"Transaction {self.id} (Type: {self.transaction_type}, Amount: {self.amount}, User: {self.user.username}) is newly completed. Updating balance.")
            self.update_user_balance()
    
    def update_user_balance(self):
        profile = self.user.profile
        logger.info(f"Before update - User: {self.user.username}, Balance: {profile.balance}, Profit: {profile.profit}, Bonus: {profile.bonus}, Investment: {profile.investment}")
        
        # Validate balance to prevent negative values
        if self.transaction_type in ['withdrawal', 'investment'] and self.status == 'completed' and profile.balance < self.amount:
            logger.error(f"Insufficient balance for {self.transaction_type}: {self.amount} > {profile.balance}")
            raise ValueError(f"Insufficient balance for {self.transaction_type}: {self.amount} > {profile.balance}")
        
        if self.transaction_type == 'deposit' and self.status == 'completed':
            profile.balance += self.amount
        elif self.transaction_type == 'withdrawal' and self.status == 'completed':
            profile.balance -= self.amount
        elif self.transaction_type == 'investment' and self.status == 'completed':
            profile.balance -= self.amount
            profile.investment += self.amount
        elif self.transaction_type == 'profit' and self.status == 'completed':
            profile.profit += self.amount
            profile.balance += self.amount
        elif self.transaction_type == 'bonus' and self.status == 'completed':
            profile.bonus += self.amount
            profile.balance += self.amount
        
        profile.save()
        logger.info(f"After update - User: {self.user.username}, Balance: {profile.balance}, Profit: {profile.profit}, Bonus: {profile.bonus}, Investment: {profile.investment}")

class Investment(models.Model):
    STATUS_CHOICES = (
        ('active', 'Active'),
        ('completed', 'Completed'),
        ('cancelled', 'Cancelled'),
    )
    
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    plan = models.ForeignKey(InvestmentPlan, on_delete=models.CASCADE)
    amount = models.DecimalField(max_digits=15, decimal_places=2)
    expected_return = models.DecimalField(max_digits=15, decimal_places=2)
    status = models.CharField(max_length=10, choices=STATUS_CHOICES, default='active')
    start_date = models.DateTimeField(auto_now_add=True)
    end_date = models.DateTimeField()
    
    def __str__(self):
        return f"{self.user.username}'s {self.plan.get_name_display()} Investment - {self.amount}"
    
    def save(self, *args, **kwargs):
        if not self.pk:  # Only on creation
            roi_percentage = self.plan.roi_percentage / Decimal('100')
            self.expected_return = self.amount + (self.amount * roi_percentage)
            self.end_date = timezone.now() + timezone.timedelta(days=self.plan.duration_days)
        elif self.plan_id != Investment.objects.get(pk=self.pk).plan_id:
            # Update expected_return and end_date if plan changes
            roi_percentage = self.plan.roi_percentage / Decimal('100')
            self.expected_return = self.amount + (self.amount * roi_percentage)
            self.end_date = self.start_date + timezone.timedelta(days=self.plan.duration_days)
        
        super().save(*args, **kwargs)

class SiteSettings(models.Model):
    site_name = models.CharField(max_length=100, default='Trading Platform')
    logo = models.ImageField(upload_to='site/logo/', null=True, blank=True)
    contact_email = models.EmailField(max_length=254, blank=True)
    contact_phone = models.CharField(max_length=20, blank=True)
    live_chat_enabled = models.BooleanField(default=False)
    live_chat_script_url = models.URLField(max_length=500, blank=True)

    def __str__(self):
        return "Site Settings"
    
class WithdrawalCode(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='withdrawal_code')
    code = models.CharField(max_length=50, unique=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return f"{self.user.username}'s Withdrawal Code"




views


from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth import authenticate, login, logout
from django.contrib.auth.models import User
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.utils import timezone
from django.db import transaction
from django.http import JsonResponse
from decimal import Decimal
from .models import (
    UserProfile, KYCVerification, Transaction,
    Cryptocurrency, Investment, InvestmentPlan, WalletAddress, WithdrawalCode
)
from .utils import (
    send_registration_email,
    send_deposit_confirmation_email,
    send_withdrawal_confirmation_email,
    send_kyc_status_email,
    generate_image_captcha,
    generate_question_captcha,
    generate_slider_captcha
)
from .forms import RegistrationForm, LoginForm, UserProfileForm
import logging
import random
import json

logger = logging.getLogger(__name__)

def generate_advanced_captcha():
    """Generate advanced CAPTCHA with multiple types."""
    captcha_types = ['image', 'question', 'slider']
    captcha_type = random.choice(captcha_types)
    
    if captcha_type == 'image':
        image_data, answer, question = generate_image_captcha()
        return {
            'type': 'image',
            'image_data': image_data,
            'question': question,
            'answer': answer
        }
    elif captcha_type == 'question':
        question, primary_answer, valid_answers = generate_question_captcha()
        return {
            'type': 'question',
            'question': question,
            'answer': primary_answer,
            'valid_answers': valid_answers
        }
    else:  # slider
        slider_data = generate_slider_captcha()
        return {
            'type': 'slider',
            'question': f"Move the slider to {slider_data['target_position']}% position",
            'answer': slider_data['target_position'],
            'slider_data': slider_data
        }

def register(request):
    if request.method == 'POST':
        # Get CAPTCHA data from session
        captcha_data = request.session.get('_captcha_data', {})
        captcha_answer = captcha_data.get('answer')
        
        form = RegistrationForm(request.POST, captcha_answer=captcha_answer)
        logger.debug(f"Registration POST data: {request.POST}")
        
        # Validate CAPTCHA based on type
        captcha_valid = False
        user_answer = request.POST.get('captcha_answer', '').strip()
        
        if captcha_data.get('type') == 'question':
            valid_answers = captcha_data.get('valid_answers', [])
            captcha_valid = user_answer.lower() in [ans.lower() for ans in valid_answers]
        elif captcha_data.get('type') == 'slider':
            try:
                user_position = float(user_answer)
                slider_data = captcha_data.get('slider_data', {})
                min_pos = slider_data.get('min_position', 0)
                max_pos = slider_data.get('max_position', 100)
                captcha_valid = min_pos <= user_position <= max_pos
            except (ValueError, TypeError):
                captcha_valid = False
        else:
            captcha_valid = user_answer.lower() == str(captcha_answer).lower()
        
        if captcha_valid and form.is_valid():
            with transaction.atomic():
                user = form.save()
                logger.debug(f"User created: {user.id}, username: {user.username}, email: {user.email}")
                
                # Update UserProfile fields after creation by the signal
                try:
                    profile = user.profile
                    profile.full_name = form.cleaned_data['full_name']
                    profile.phone = form.cleaned_data.get('phone', '')
                    profile.country = form.cleaned_data.get('country', '')
                    profile.currency = form.cleaned_data.get('currency', 'USD')
                    profile.save()
                    logger.debug(f"UserProfile updated for user: {user.username}")
                except UserProfile.DoesNotExist:
                    logger.error(f"UserProfile not found for user: {user.username}")
                    messages.error(request, 'Profile creation failed. Please contact support.')
                    return redirect('main:login')
                
                # Authenticate the user
                username = user.username
                password = form.cleaned_data['password']
                authenticated_user = authenticate(request, username=username, password=password)
                
                if authenticated_user is not None:
                    login(request, authenticated_user)
                    logger.info(f"New user registered and logged in: {username}, currency: {form.cleaned_data.get('currency', 'USD')}")
                    try:
                        send_registration_email(user)
                    except Exception as e:
                        logger.error(f"Error sending registration email: {e}")
                    
                    messages.success(request, 'Registration successful!')
                    # Clean up session
                    if '_captcha_data' in request.session:
                        del request.session['_captcha_data']
                    return redirect('main:dashboard')
                else:
                    logger.warning(f"Authentication failed after registration for username: {username}")
                    # Check if user exists in database
                    try:
                        user_check = User.objects.get(username=username)
                        logger.debug(f"User exists in database: {user_check.username}, is_active: {user_check.is_active}")
                    except User.DoesNotExist:
                        logger.error(f"User not found in database after creation: {username}")
                    
                    messages.error(request, 'Registration successful, but login failed. Please try logging in.')
                    return redirect('main:login')
        else:
            if not captcha_valid:
                logger.warning(f"Invalid CAPTCHA from IP {request.META.get('REMOTE_ADDR')}")
                messages.error(request, 'Invalid CAPTCHA answer. Please try again.')
            
            logger.warning(f"Failed registration attempt from IP {request.META.get('REMOTE_ADDR')}: {form.errors}")
            for error in form.errors.values():
                messages.error(request, error)
            
            # Generate new CAPTCHA for invalid form
            captcha_data = generate_advanced_captcha()
            request.session['_captcha_data'] = captcha_data
            request.session.modified = True
            logger.debug(f"New CAPTCHA generated: {captcha_data['type']}")
    else:
        # Initial GET request
        captcha_data = generate_advanced_captcha()
        request.session['_captcha_data'] = captcha_data
        request.session.modified = True
        logger.debug(f"Initial CAPTCHA generated: {captcha_data['type']}")
        form = RegistrationForm()
    
    return render(request, 'main/register.html', {
        'form': form,
        'captcha_data': captcha_data
    })



def login_view(request):
    if request.method == 'POST':
        # Get CAPTCHA data from session
        captcha_data = request.session.get('_captcha_data', {})
        captcha_answer = captcha_data.get('answer', '')
        
        form = LoginForm(request.POST, captcha_answer=captcha_answer)
        logger.debug(f"Login POST data: {request.POST}")
        
        # Validate CAPTCHA based on type
        captcha_valid = False
        user_answer = request.POST.get('captcha_answer', '').strip()
        
        if captcha_data.get('type') == 'question':
            valid_answers = captcha_data.get('valid_answers', [])
            captcha_valid = user_answer.lower() in [str(ans).lower() for ans in valid_answers]
        elif captcha_data.get('type') == 'slider':
            try:
                user_position = float(user_answer)
                slider_data = captcha_data.get('slider_data', {})
                min_pos = slider_data.get('min_position', 0)
                max_pos = slider_data.get('max_position', 100)
                captcha_valid = min_pos <= user_position <= max_pos
            except (ValueError, TypeError):
                captcha_valid = False
        else:
            captcha_valid = user_answer.lower() == str(captcha_answer).lower()
        
        if captcha_valid and form.is_valid():
            username = form.cleaned_data['username']
            password = form.cleaned_data['password']
            user = authenticate(request, username=username, password=password)
            if user is not None:
                login(request, user)
                if '_captcha_data' in request.session:
                    del request.session['_captcha_data']
                logger.info(f"User logged in: {username}")
                messages.success(request, 'Login successful.')
                return redirect('main:dashboard')
            else:
                logger.warning(f"Failed login attempt for {username} from IP {request.META.get('REMOTE_ADDR')}")
                messages.error(request, 'Invalid username or password.')
        else:
            if not captcha_valid:
                logger.warning(f"Invalid CAPTCHA from IP {request.META.get('REMOTE_ADDR')}")
                messages.error(request, 'Invalid CAPTCHA answer. Please try again.')
            
            logger.warning(f"Failed login attempt from IP {request.META.get('REMOTE_ADDR')}: {form.errors}")
            for error in form.errors.values():
                messages.error(request, error)
        
        # Generate new CAPTCHA for any failed attempt
        captcha_data = generate_advanced_captcha()
        request.session['_captcha_data'] = captcha_data
        request.session.modified = True
    else:
        captcha_data = generate_advanced_captcha()
        request.session['_captcha_data'] = captcha_data
        request.session.modified = True
        form = LoginForm()
    
    return render(request, 'main/login.html', {
        'form': form,
        'captcha_data': captcha_data
    })

def refresh_captcha(request):
    """AJAX endpoint to refresh CAPTCHA."""
    if request.method == 'POST':
        captcha_data = generate_advanced_captcha()
        request.session['_captcha_data'] = captcha_data
        request.session.modified = True
        
        return JsonResponse({
            'success': True,
            'captcha_data': captcha_data
        })
    
    return JsonResponse({'success': False})

@login_required
def logout_view(request):
    logout(request)
    return redirect('main:home')

@login_required
def kyc_verification(request):
    try:
        kyc = KYCVerification.objects.get(user=request.user)
        kyc_exists = True
    except KYCVerification.DoesNotExist:
        kyc = None
        kyc_exists = False
    
    logger.info(f"KYC exists: {kyc_exists}, Status: {kyc.status if kyc else 'None'}")
    
    if request.method == 'POST' and not (kyc_exists and kyc.status in ['approved', 'submitted']):
        logger.info(f"request.FILES: {request.FILES}")
        # Validate id_type and id_number
        if not request.POST.get('id_type') or not request.POST.get('id_number'):
            logger.error(f"Missing id_type or id_number: id_type={request.POST.get('id_type')}, id_number={request.POST.get('id_number')}")
            messages.error(request, 'Please provide both ID type and ID number.')
            return redirect('main:kyc_verification')
        
        # Validate all files
        if 'id_front' not in request.FILES or 'id_back' not in request.FILES or 'selfie' not in request.FILES:
            logger.error(f"Missing files: id_front={bool('id_front' in request.FILES)}, id_back={bool('id_back' in request.FILES)}, selfie={bool('selfie' in request.FILES)}")
            messages.error(request, 'Please upload all required documents.')
            return redirect('main:kyc_verification')
        
        if kyc_exists:
            kyc.id_type = request.POST.get('id_type')
            kyc.id_number = request.POST.get('id_number')
            kyc.status = 'submitted'
            kyc.submitted_at = timezone.now()
            kyc.id_front = request.FILES['id_front']
            kyc.id_back = request.FILES['id_back']
            kyc.selfie = request.FILES['selfie']
            kyc.rejection_reason = None
            kyc.save()
        else:
            kyc = KYCVerification.objects.create(
                user=request.user,
                id_type=request.POST.get('id_type'),
                id_number=request.POST.get('id_number'),
                id_front=request.FILES['id_front'],
                id_back=request.FILES['id_back'],
                selfie=request.FILES['selfie'],
                status='submitted',
                submitted_at=timezone.now()
            )
        
        try:
            send_kyc_status_email(request.user, kyc, 'submitted')
        except Exception as e:
            logger.error(f"Error sending KYC submission email: {e}")
        
        messages.success(request, 'KYC verification submitted successfully.')
        return redirect('main:dashboard')
    
    context = {'kyc': kyc}
    return render(request, 'main/kyc_verification.html', context)

@login_required
def deposit(request):
    try:
        kyc = KYCVerification.objects.get(user=request.user)
        kyc_approved = kyc.status == 'approved'
    except KYCVerification.DoesNotExist:
        kyc_approved = False
    
    cryptocurrencies = Cryptocurrency.objects.filter(is_active=True)
    profile = request.user.profile
    
    if request.method == 'POST' and kyc_approved:
        try:
            amount = Decimal(request.POST.get('amount'))
        except (ValueError, TypeError):
            logger.error(f"Invalid amount provided: {request.POST.get('amount')}")
            messages.error(request, 'Invalid deposit amount.')
            return redirect('main:deposit')
            
        payment_method = request.POST.get('payment_method')
        
        # Validate amount
        if amount < Decimal('10'):
            messages.error(request, f'Minimum deposit amount is 10 {profile.currency}.')
            return redirect('main:deposit')
        
        new_transaction = Transaction(
            user=request.user,
            transaction_type='deposit',
            amount=amount,
            payment_method=payment_method,
            status='pending'
        )
        
        if payment_method == 'crypto':
            crypto_id = request.POST.get('cryptocurrency')
            if crypto_id:
                try:
                    cryptocurrency = Cryptocurrency.objects.get(id=crypto_id)
                    new_transaction.cryptocurrency_id = cryptocurrency.id
                except Cryptocurrency.DoesNotExist:
                    messages.error(request, 'Invalid cryptocurrency selected.')
                    return redirect('main:deposit')
            
            # Require payment proof for crypto deposits
            if 'payment_proof' not in request.FILES:
                messages.error(request, 'Please upload payment proof for cryptocurrency deposits.')
                return redirect('main:deposit')
            new_transaction.payment_proof = request.FILES['payment_proof']
        
        new_transaction.save()
        
        try:
            send_deposit_confirmation_email(request.user, new_transaction)
        except Exception as e:
            logger.error(f"Error sending deposit confirmation email: {e}")
        
        messages.success(request, 'Deposit request submitted successfully.')
        return redirect('main:dashboard')
    
    deposits = Transaction.objects.filter(
        user=request.user,
        transaction_type='deposit'
    ).order_by('-created_at')[:5]
    
    context = {
        'kyc_approved': kyc_approved,
        'deposits': deposits,
        'cryptocurrencies': cryptocurrencies,
        'profile': profile,
        'currency': profile.currency
    }
    return render(request, 'main/deposit.html', context)

@login_required
def withdraw(request):
    try:
        kyc = KYCVerification.objects.get(user=request.user)
        kyc_approved = kyc.status == 'approved'
    except KYCVerification.DoesNotExist:
        kyc_approved = False
    
    cryptocurrencies = Cryptocurrency.objects.filter(is_active=True)
    profile = request.user.profile
    wallet_addresses = request.user.wallet_addresses.filter(is_active=True)
    
    if request.method == 'POST' and kyc_approved:
        try:
            amount = Decimal(request.POST.get('amount'))
        except (ValueError, TypeError):
            logger.error(f"Invalid withdrawal amount: {request.POST.get('amount')}")
            messages.error(request, 'Invalid withdrawal amount.')
            return redirect('main:withdraw')
            
        wallet_id = request.POST.get('wallet_id')
        
        if amount > profile.balance:
            messages.error(request, f'Insufficient balance for withdrawal: {amount} {profile.currency} > {profile.balance} {profile.currency}')
            return redirect('main:withdraw')
        
        try:
            wallet = request.user.wallet_addresses.get(id=wallet_id)
        except WalletAddress.DoesNotExist:
            messages.error(request, 'Invalid wallet address selected.')
            return redirect('main:withdraw')
        
        # Store details in session for authentication
        request.session['pending_withdrawal'] = {
            'amount': str(amount),
            'wallet_id': wallet_id,
            'cryptocurrency_id': wallet.cryptocurrency.id
        }
        request.session.modified = True
        return redirect('main:withdrawal_auth')
    
    withdrawals = Transaction.objects.filter(
        user=request.user,
        transaction_type='withdrawal'
    ).order_by('-created_at')[:5]
    
    context = {
        'kyc_approved': kyc_approved,
        'withdrawals': withdrawals,
        'balance': profile.balance,
        'currency': profile.currency,
        'cryptocurrencies': cryptocurrencies,
        'wallet_addresses': wallet_addresses,
        'profile': profile
    }
    return render(request, 'main/withdraw.html', context)

@login_required
def investments(request):
    try:
        kyc = KYCVerification.objects.get(user=request.user)
        kyc_approved = kyc.status == 'approved'
    except KYCVerification.DoesNotExist:
        kyc_approved = False
    
    profile = request.user.profile
    
    if not kyc_approved:
        messages.warning(request, 'You need to complete KYC verification to access investment features.')
        return redirect('main:kyc_verification')
    
    plans = InvestmentPlan.objects.filter(is_active=True)
    
    if request.method == 'POST':
        plan_id = request.POST.get('plan_id')
        try:
            amount = Decimal(request.POST.get('amount'))
        except (ValueError, TypeError):
            logger.error(f"Invalid amount provided for user {request.user.username}: {request.POST.get('amount')}")
            messages.error(request, 'Invalid investment amount.')
            return redirect('main:investments')
        
        if not plan_id:
            logger.error(f"No plan_id provided for user {request.user.username}")
            messages.error(request, 'No investment plan selected.')
            return redirect('main:investments')
        
        try:
            plan = InvestmentPlan.objects.get(id=plan_id, is_active=True)
            
            if amount < plan.min_deposit or amount > plan.max_deposit:
                logger.warning(f"Investment amount {amount} {profile.currency} out of range for plan {plan.name} (min: {plan.min_deposit}, max: {plan.max_deposit})")
                messages.error(request, f'Investment amount must be between {plan.min_deposit} {profile.currency} and {plan.max_deposit} {profile.currency}.')
                return redirect('main:investments')
            
            if amount > profile.balance:
                logger.warning(f"Insufficient balance for user {request.user.username}: {amount} {profile.currency} > {profile.balance} {profile.currency}")
                messages.error(request, f'Insufficient balance for investment: {amount} {profile.currency} > {profile.balance} {profile.currency}')
                return redirect('main:investments')
            
            with transaction.atomic():
                logger.info(f"Creating investment for user {request.user.username}, amount: {amount} {profile.currency}, plan: {plan.name}")
                
                # Create investment
                investment = Investment(
                    user=request.user,
                    plan=plan,
                    amount=amount,
                    status='active'
                )
                investment.save()
                
                # Create transaction record
                new_transaction = Transaction(
                    user=request.user,
                    transaction_type='investment',
                    amount=amount,
                    payment_method='internal',
                    status='completed',
                    completed_at=timezone.now()
                )
                new_transaction.save()
                
                logger.info(f"Investment transaction created: ID {new_transaction.id}, amount: {amount} {profile.currency}")
                
                messages.success(
                    request, 
                    f'Investment of {amount} {profile.currency} in {plan.name} plan successful.'
                )
                return redirect('main:dashboard')
            
        except InvestmentPlan.DoesNotExist:
            logger.error(f"Investment plan {plan_id} does not exist for user {request.user.username}")
            messages.error(request, 'Invalid investment plan selected.')
            return redirect('main:investments')
    
    active_investments = Investment.objects.filter(
        user=request.user,
        status='active'
    ).order_by('-start_date')
    
    completed_investments = Investment.objects.filter(
        user=request.user,
        status='completed'
    ).order_by('-end_date')[:10]
    
    context = {
        'plans': plans,
        'active_investments': active_investments,
        'completed_investments': completed_investments,
        'balance': profile.balance,
        'currency': profile.currency,
        'investment': profile.investment,
        'profile': profile
    }
    return render(request, 'main/investments.html', context)

@login_required
def dashboard(request):
    try:
        kyc = KYCVerification.objects.get(user=request.user)
        if kyc.status not in ['approved', 'submitted']:
            messages.warning(request, 'Please complete KYC verification to access your dashboard.')
            return redirect('main:kyc_verification')
        kyc_status = kyc.status
    except KYCVerification.DoesNotExist:
        messages.warning(request, 'Please complete KYC verification to access your dashboard.')
        return redirect('main:kyc_verification')
    
    profile = request.user.profile
    transactions = Transaction.objects.filter(user=request.user).order_by('-created_at')[:5]
    
    total_deposits = Transaction.objects.filter(
        user=request.user, 
        transaction_type='deposit',
        status='completed'
    ).count()
    
    total_withdrawals = Transaction.objects.filter(
        user=request.user, 
        transaction_type='withdrawal',
        status='completed'
    ).count()
    
    active_investments = Investment.objects.filter(
        user=request.user,
        status='active'
    ).order_by('-start_date')[:3]
    
    context = {
        'profile': profile,
        'transactions': transactions,
        'total_deposits': total_deposits,
        'total_withdrawals': total_withdrawals,
        'active_investments': active_investments,
        'kyc_status': kyc_status,
        'balance': profile.balance,
        'currency': profile.currency,
        'profit': profile.profit,
        'bonus': profile.bonus,
        'investment': profile.investment
    }
    return render(request, 'main/dashboard.html', context)

@login_required
def settings(request):
    profile = request.user.profile
    cryptocurrencies = Cryptocurrency.objects.filter(is_active=True)
    wallet_addresses = request.user.wallet_addresses.filter(is_active=True)
    
    if request.method == 'POST':
        if 'update_profile' in request.POST:
            form = UserProfileForm(request.POST, instance=profile, user=request.user)
            if form.is_valid():
                form.save()
                logger.info(f"Profile updated for user {request.user.username}: currency={form.cleaned_data['currency']}")
                messages.success(request, 'Profile updated successfully.')
                return redirect('main:settings')
            else:
                logger.error(f"Profile update failed for user {request.user.username}: {form.errors}")
                for error in form.errors.values():
                    messages.error(request, error)
        
        elif 'add_wallet' in request.POST:
            crypto_id = request.POST.get('cryptocurrency')
            wallet_address = request.POST.get('wallet_address')
            if crypto_id and wallet_address:
                try:
                    cryptocurrency = Cryptocurrency.objects.get(id=crypto_id)
                    WalletAddress.objects.create(
                        user=request.user,
                        cryptocurrency=cryptocurrency,
                        address=wallet_address
                    )
                    messages.success(request, 'Wallet address added successfully.')
                except Cryptocurrency.DoesNotExist:
                    messages.error(request, 'Invalid cryptocurrency selected.')
                return redirect('main:settings')
            else:
                messages.error(request, 'Please provide both cryptocurrency and wallet address.')
            return redirect('main:settings')
        
        elif 'delete_wallet' in request.POST:
            wallet_id = request.POST.get('wallet_id')
            try:
                wallet = WalletAddress.objects.get(id=wallet_id, user=request.user)
                wallet.delete()
                messages.success(request, 'Wallet address deleted successfully.')
            except WalletAddress.DoesNotExist:
                messages.error(request, 'Invalid wallet address.')
            return redirect('main:settings')
        
        elif 'password_change' in request.POST:
            current_password = request.POST.get('current_password')
            new_password = request.POST.get('new_password')
            confirm_password = request.POST.get('confirm_password')
            
            if not request.user.check_password(current_password):
                messages.error(request, 'Current password is incorrect.')
                return redirect('main:settings')
            
            if new_password != confirm_password:
                messages.error(request, 'New passwords do not match.')
                return redirect('main:settings')
            
            request.user.set_password(new_password)
            request.user.save()
            
            user = authenticate(request, username=request.user.username, password=new_password)
            login(request, user)
            
            logger.info(f"Password changed for user {request.user.username}")
            messages.success(request, 'Password changed successfully.')
            return redirect('main:settings')
    
    else:
        form = UserProfileForm(instance=profile, user=request.user)
    
    context = {
        'form': form,
        'cryptocurrencies': cryptocurrencies,
        'wallet_addresses': wallet_addresses,
        'profile': profile,
        'currency': profile.currency
    }
    return render(request, 'main/settings.html', context)

@login_required
def withdrawal_auth(request):
    if 'pending_withdrawal' not in request.session:
        messages.error(request, 'No pending withdrawal found.')
        return redirect('main:withdraw')
    
    withdrawal_data = request.session['pending_withdrawal']
    
    if request.method == 'POST':
        code = request.POST.get('auth_code')
        try:
            withdrawal_code = WithdrawalCode.objects.get(user=request.user)
            if code != withdrawal_code.code:
                messages.error(request, 'Invalid withdrawal code.')
                return redirect('main:withdrawal_auth')
            
            amount = Decimal(withdrawal_data['amount'])
            wallet_id = withdrawal_data['wallet_id']
            crypto_id = withdrawal_data['cryptocurrency_id']
            
            profile = request.user.profile
            if amount > profile.balance:
                messages.error(request, f'Insufficient balance for withdrawal: {amount} {profile.currency} > {profile.balance} {profile.currency}')
                return redirect('main:withdraw')
            
            wallet = WalletAddress.objects.get(id=wallet_id, user=request.user)
            
            profile.balance -= amount
            profile.save()
            
            new_transaction = Transaction(
                user=request.user,
                transaction_type='withdrawal',
                amount=amount,
                wallet_address=wallet.address,
                status='pending',
                cryptocurrency_id=crypto_id
            )
            new_transaction.save()
            
            try:
                send_withdrawal_confirmation_email(request.user, new_transaction)
            except Exception as e:
                logger.error(f"Error sending withdrawal confirmation email: {e}")
            
            # Clear session data
            del request.session['pending_withdrawal']
            request.session.modified = True
            
            messages.success(request, 'Withdrawal request submitted successfully.')
            return redirect('main:dashboard')
        
        except WithdrawalCode.DoesNotExist:
            messages.error(request, 'No withdrawal code assigned. Please contact support.')
            return redirect('main:withdraw')
    
    return render(request, 'main/withdrawal_auth.html')

# Static Pages
def home(request):
    return render(request, 'main/home.html')

def about(request):
    return render(request, 'main/about.html')

def terms(request):
    return render(request, 'main/terms.html')

def privacy(request):
    return render(request, 'main/privacy.html')

def demo(request):
    return render(request, 'main/demo.html')

# Custom Error Views
def custom_404(request, exception):
    logger.error(f"404 Error: {request.path}")
    return render(request, 'main/404.html', status=404)

def custom_403(request, exception):
    logger.error(f"403 Error: {request.path} - User: {request.user.username if request.user.is_authenticated else 'Anonymous'}")
    return render(request, 'main/403.html', status=403)

def custom_500(request):
    logger.error(f"500 Error: {request.path}")
    return render(request, 'main/500.html', status=500)


utils.py


from django.core.mail import send_mail
from django.template.loader import render_to_string
from django.utils.html import strip_tags
from django.conf import settings
from django.contrib.auth.models import User
from django.db import connection

def update_profile_balance(user_id, balance_change, profit_change=0, loss_change=0):
    """
    Update a user's profile balance, profit, and loss directly using SQL
    to avoid any potential ORM issues.
    """
    with connection.cursor() as cursor:
        # Update the balance
        cursor.execute(
            "UPDATE trading_userprofile SET balance = balance + %s WHERE user_id = %s",
            [balance_change, user_id]
        )
        
        # Update profit if needed
        if profit_change != 0:
            cursor.execute(
                "UPDATE trading_userprofile SET profit = profit + %s WHERE user_id = %s",
                [profit_change, user_id]
            )
        
        # Update loss if needed
        if loss_change != 0:
            cursor.execute(
                "UPDATE trading_userprofile SET loss = loss + %s WHERE user_id = %s",
                [loss_change, user_id]
            )
        
        # Commit the transaction
        connection.commit()


def send_email_notification(subject, template, recipient_list, context):
    """
    Send an email notification using a template.
    
    Args:
        subject (str): Email subject
        template (str): Path to the email template
        recipient_list (list): List of recipient email addresses
        context (dict): Context data for the template
    """
    html_message = render_to_string(template, context)
    plain_message = strip_tags(html_message)
    
    send_mail(
        subject=subject,
        message=plain_message,
        from_email=settings.DEFAULT_FROM_EMAIL,
        recipient_list=recipient_list,
        html_message=html_message,
        fail_silently=False,
    )

def send_registration_email(user):
    """Send a welcome email to a newly registered user."""
    subject = 'Welcome to Trading Platform'
    template = 'emails/welcome_email.html'
    recipient_list = [user.email]
    context = {
        'user': user,
        'full_name': user.profile.full_name
    }
    
    send_email_notification(subject, template, recipient_list, context)
    
    # Notify admin about new registration
    send_admin_notification(
        subject="New User Registration",
        message=f"A new user has registered: {user.username} ({user.email})"
    )

def send_deposit_confirmation_email(user, transaction):
    """Send a deposit confirmation email."""
    subject = 'Deposit Received - Trading Platform'
    template = 'emails/deposit_confirmation.html'
    recipient_list = [user.email]
    context = {
        'user': user,
        'full_name': user.profile.full_name,
        'transaction': transaction
    }
    
    send_email_notification(subject, template, recipient_list, context)
    
    # Notify admin about new deposit
    send_admin_notification(
        subject="New Deposit Request",
        message=f"User {user.username} has submitted a deposit request for ${transaction.amount}"
    )

def send_withdrawal_confirmation_email(user, transaction):
    """Send a withdrawal confirmation email."""
    subject = 'Withdrawal Request Received - Trading Platform'
    template = 'emails/withdrawal_confirmation.html'
    recipient_list = [user.email]
    context = {
        'user': user,
        'full_name': user.profile.full_name,
        'transaction': transaction
    }
    
    send_email_notification(subject, template, recipient_list, context)
    
    # Notify admin about new withdrawal
    send_admin_notification(
        subject="New Withdrawal Request",
        message=f"User {user.username} has submitted a withdrawal request for ${transaction.amount}"
    )

def send_kyc_status_email(user, kyc, status):
    """Send a KYC status update email."""
    subject = f'KYC Verification {status.capitalize()} - Trading Platform'
    template = 'emails/kyc_status.html'
    recipient_list = [user.email]
    context = {
        'user': user,
        'full_name': user.profile.full_name,
        'kyc': kyc,
        'status': status
    }
    
    send_email_notification(subject, template, recipient_list, context)

def send_transaction_status_email(user, transaction, status):
    """Send a transaction status update email."""
    transaction_type = transaction.get_transaction_type_display()
    subject = f'{transaction_type} {status.capitalize()} - Trading Platform'
    template = 'emails/transaction_status.html'
    recipient_list = [user.email]
    context = {
        'user': user,
        'full_name': user.profile.full_name,
        'transaction': transaction,
        'status': status,
        'transaction_type': transaction_type
    }
    
    send_email_notification(subject, template, recipient_list, context)

def send_admin_notification(subject, message):
    """Send a notification to all admin users."""
    admin_emails = User.objects.filter(is_staff=True).values_list('email', flat=True)
    
    if admin_emails:
        send_mail(
            subject=f"[ADMIN] {subject}",
            message=message,
            from_email=settings.DEFAULT_FROM_EMAIL,
            recipient_list=list(admin_emails),
            fail_silently=False,
        )

from django.db import connection
from decimal import Decimal

def update_profile_directly(user_id, balance_delta=0, profit_delta=0, loss_delta=0):
    """
    Update a user profile directly using SQL to bypass any potential ORM issues.
    """
    with connection.cursor() as cursor:
        # Get the table name (adjust if your app name is different)
        table_name = 'main_userprofile'
        
        # Update balance if needed
        if balance_delta != 0:
            cursor.execute(
                f"UPDATE {table_name} SET balance = balance + %s WHERE user_id = %s",
                [str(balance_delta), user_id]
            )
        
        # Update profit if needed
        if profit_delta != 0:
            cursor.execute(
                f"UPDATE {table_name} SET profit = profit + %s WHERE user_id = %s",
                [str(profit_delta), user_id]
            )
        
        # Update loss if needed
        if loss_delta != 0:
            cursor.execute(
                f"UPDATE {table_name} SET loss = loss + %s WHERE user_id = %s",
                [str(loss_delta), user_id]
            )
        
        # Get the updated values for verification
        cursor.execute(
            f"SELECT balance, profit, loss FROM {table_name} WHERE user_id = %s",
            [user_id]
        )
        result = cursor.fetchone()
        
        return {
            'balance': result[0] if result else None,
            'profit': result[1] if result else None,
            'loss': result[2] if result else None
        }

def log_transaction_processing(transaction_id, user_id, action, details):
    """
    Log transaction processing details for debugging purposes
    """
    print(f"TRANSACTION {action.upper()} - ID: {transaction_id}, User: {user_id}")
    for key, value in details.items():
        print(f"TRANSACTION {action.upper()} - {key}: {value}")
    
def update_balance_directly(user_id, amount_delta):
    """
    Update a user's balance directly using SQL to bypass any potential ORM issues.
    
    Args:
        user_id: The user ID
        amount_delta: The amount to add (positive) or subtract (negative)
        
    Returns:
        dict: The old and new balance
    """
    with connection.cursor() as cursor:
        # First get the current balance
        cursor.execute(
            "SELECT balance FROM main_userprofile WHERE user_id = %s",
            [user_id]
        )
        result = cursor.fetchone()
        old_balance = result[0] if result else 0
        
        # Update the balance
        cursor.execute(
            "UPDATE main_userprofile SET balance = balance + %s WHERE user_id = %s",
            [str(amount_delta), user_id]
        )
        
        # Get the new balance
        cursor.execute(
            "SELECT balance FROM main_userprofile WHERE user_id = %s",
            [user_id]
        )
        result = cursor.fetchone()
        new_balance = result[0] if result else 0
        
        return {
            'old_balance': old_balance,
            'new_balance': new_balance
        }

# Add this function to your utils.py file

def send_action_notification_email(user, action):
    """Send notification email for a required action"""
    subject = f"Action Required: {action.get_action_type_display()}"
    
    if action.action_type == 'upgrade':
        plan_name = action.target_plan.get_name_display() if action.target_plan else "higher plan"
        message = f"Dear {user.username},\n\nYou are required to upgrade to the {plan_name} investment plan. "
        message += f"The upgrade cost is ${action.amount}.\n\n"
        
    elif action.action_type == 'signal':
        signal_name = action.signal_plan.name if action.signal_plan else "trading signals"
        message = f"Dear {user.username},\n\nYou are required to purchase the {signal_name} package. "
        message += f"The cost is ${action.amount}.\n\n"
    
    # Add custom message if provided
    if action.message:
        message += f"{action.message}\n\n"
    
    message += "Please log in to your account to complete this action.\n\n"
    message += f"This action is {'mandatory' if action.is_mandatory else 'optional'}.\n\n"
    message += "Thank you,\nTrading Platform Team"
    
    from_email = settings.DEFAULT_FROM_EMAIL
    recipient_list = [user.email]
    
    try:
        send_mail(subject, message, from_email, recipient_list, fail_silently=False)
        return True
    except Exception as e:
        print(f"Error sending email to {user.email}: {str(e)}")
        return False

from django.core.mail import send_mail
from django.conf import settings

def send_kyc_status_email(user, kyc, status):
    subject = f"KYC Verification {status.capitalize()} - Trading Platform"
    message = f"""
    Hello {user.username},

    Your KYC verification has been {status}.

    Details:
    ID Type: {kyc.id_type}
    ID Number: {kyc.id_number}
    Status: {status.capitalize()}
    Reviewed: {kyc.reviewed_at}

    Thank you,
    Trading Platform Team
    """
    send_mail(
        subject,
        message,
        settings.DEFAULT_FROM_EMAIL,
        [user.email],
        fail_silently=False,
    )

def send_bonus_email(user, bonus_amount, add_to_balance):
    subject = "Bonus Added to Your Account - Trading Platform"
    message = f"""
    Hello {user.username},

    A bonus of {user.profile.currency} {bonus_amount} has been added to your account.

    {'This bonus has also been added to your main balance.' if add_to_balance else 'This bonus is available in your bonus balance.'}

    Current Balances:
    Bonus: {user.profile.currency} {user.profile.bonus}
    Main Balance: {user.profile.currency} {user.profile.balance}

    Thank you,
    Trading Platform Team
    """
    send_mail(
        subject,
        message,
        settings.DEFAULT_FROM_EMAIL,
        [user.email],
        fail_silently=False,
    )

from PIL import Image, ImageDraw, ImageFont, ImageFilter
import random
import string
import io
import base64
import math

def generate_image_captcha():
    """Generate an image-based CAPTCHA with mathematical expression or text."""
    
    # Choose CAPTCHA type
    captcha_type = random.choice(['math', 'text', 'word_math'])
    
    if captcha_type == 'math':
        return generate_math_image_captcha()
    elif captcha_type == 'text':
        return generate_text_image_captcha()
    else:
        return generate_word_math_captcha()

def generate_math_image_captcha():
    """Generate mathematical expression CAPTCHA."""
    # Generate random math problem
    operations = [
        lambda: (random.randint(10, 50), random.randint(1, 20), '+'),
        lambda: (random.randint(20, 80), random.randint(1, 30), '-'),
        lambda: (random.randint(2, 12), random.randint(2, 9), '*'),
    ]
    
    num1, num2, op = random.choice(operations)()
    
    if op == '+':
        answer = num1 + num2
    elif op == '-':
        answer = num1 - num2
    else:  # multiplication
        answer = num1 * num2
    
    question = f"{num1} {op} {num2} = ?"
    
    # Create image
    img = Image.new('RGB', (200, 80), color='white')
    draw = ImageDraw.Draw(img)
    
    # Add some noise
    for _ in range(100):
        x = random.randint(0, 200)
        y = random.randint(0, 80)
        draw.point((x, y), fill=(random.randint(200, 255), random.randint(200, 255), random.randint(200, 255)))
    
    # Draw text with some distortion
    try:
        font = ImageFont.truetype("arial.ttf", 24)
    except:
        font = ImageFont.load_default()
    
    # Add text with slight rotation and color variation
    text_color = (random.randint(0, 100), random.randint(0, 100), random.randint(0, 100))
    
    # Calculate text position to center it
    bbox = draw.textbbox((0, 0), question, font=font)
    text_width = bbox[2] - bbox[0]
    text_height = bbox[3] - bbox[1]
    x = (200 - text_width) // 2
    y = (80 - text_height) // 2
    
    draw.text((x, y), question, fill=text_color, font=font)
    
    # Add some lines for distraction
    for _ in range(3):
        start = (random.randint(0, 200), random.randint(0, 80))
        end = (random.randint(0, 200), random.randint(0, 80))
        draw.line([start, end], fill=(random.randint(150, 200), random.randint(150, 200), random.randint(150, 200)), width=1)
    
    # Convert to base64
    buffer = io.BytesIO()
    img.save(buffer, format='PNG')
    img_str = base64.b64encode(buffer.getvalue()).decode()
    
    return f"data:image/png;base64,{img_str}", str(answer), f"Solve: {question}"

def generate_text_image_captcha():
    """Generate text-based CAPTCHA."""
    # Generate random string
    chars = string.ascii_uppercase + string.digits
    text = ''.join(random.choices(chars, k=5))
    
    # Create image
    img = Image.new('RGB', (150, 60), color='white')
    draw = ImageDraw.Draw(img)
    
    # Add background noise
    for _ in range(200):
        x = random.randint(0, 150)
        y = random.randint(0, 60)
        draw.point((x, y), fill=(random.randint(200, 255), random.randint(200, 255), random.randint(200, 255)))
    
    try:
        font = ImageFont.truetype("arial.ttf", 28)
    except:
        font = ImageFont.load_default()
    
    # Draw each character with slight variations
    x_offset = 10
    for char in text:
        color = (random.randint(0, 100), random.randint(0, 100), random.randint(0, 100))
        y_offset = random.randint(10, 20)
        draw.text((x_offset, y_offset), char, fill=color, font=font)
        x_offset += random.randint(20, 30)
    
    # Add distraction lines
    for _ in range(5):
        start = (random.randint(0, 150), random.randint(0, 60))
        end = (random.randint(0, 150), random.randint(0, 60))
        draw.line([start, end], fill=(random.randint(150, 200), random.randint(150, 200), random.randint(150, 200)), width=1)
    
    # Convert to base64
    buffer = io.BytesIO()
    img.save(buffer, format='PNG')
    img_str = base64.b64encode(buffer.getvalue()).decode()
    
    return f"data:image/png;base64,{img_str}", text.lower(), f"Enter the text shown in the image"

def generate_word_math_captcha():
    """Generate word-based math CAPTCHA."""
    numbers_word = {
        1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five',
        6: 'six', 7: 'seven', 8: 'eight', 9: 'nine', 10: 'ten'
    }
    
    num1 = random.randint(1, 10)
    num2 = random.randint(1, 5)
    operation = random.choice(['plus', 'minus'])
    
    if operation == 'plus':
        answer = num1 + num2
        question = f"{numbers_word[num1]} plus {numbers_word[num2]}"
    else:
        if num1 < num2:
            num1, num2 = num2, num1
        answer = num1 - num2
        question = f"{numbers_word[num1]} minus {numbers_word[num2]}"
    
    # Create image
    img = Image.new('RGB', (250, 80), color='white')
    draw = ImageDraw.Draw(img)
    
    # Add noise
    for _ in range(150):
        x = random.randint(0, 250)
        y = random.randint(0, 80)
        draw.point((x, y), fill=(random.randint(200, 255), random.randint(200, 255), random.randint(200, 255)))
    
    try:
        font = ImageFont.truetype("arial.ttf", 20)
    except:
        font = ImageFont.load_default()
    
    # Center the text
    bbox = draw.textbbox((0, 0), question, font=font)
    text_width = bbox[2] - bbox[0]
    text_height = bbox[3] - bbox[1]
    x = (250 - text_width) // 2
    y = (80 - text_height) // 2
    
    color = (random.randint(0, 100), random.randint(0, 100), random.randint(0, 100))
    draw.text((x, y), question, fill=color, font=font)
    
    # Convert to base64
    buffer = io.BytesIO()
    img.save(buffer, format='PNG')
    img_str = base64.b64encode(buffer.getvalue()).decode()
    
    return f"data:image/png;base64,{img_str}", str(answer), f"Solve: {question} = ?"

def generate_question_captcha():
    """Generate question-based CAPTCHA."""
    questions = [
        ("What color is the sky on a clear day?", ["blue", "blu"]),
        ("How many days are in a week?", ["7", "seven"]),
        ("What is the opposite of hot?", ["cold", "cool"]),
        ("What do bees make?", ["honey"]),
        ("What is 2 + 2?", ["4", "four"]),
        ("What animal says 'meow'?", ["cat", "kitten"]),
        ("What is the first month of the year?", ["january", "jan"]),
        ("How many wheels does a bicycle have?", ["2", "two"]),
        ("What do you use to write with a pen?", ["ink"]),
        ("What is the opposite of up?", ["down"]),
        ("What color do you get when you mix red and white?", ["pink"]),
        ("What is the capital of France?", ["paris"]),
        ("How many minutes are in an hour?", ["60", "sixty"]),
        ("What season comes after winter?", ["spring"]),
        ("What is the largest ocean on Earth?", ["pacific"]),
    ]
    
    question, valid_answers = random.choice(questions)
    return question, valid_answers[0], valid_answers

def generate_slider_captcha():
    """Generate slider puzzle CAPTCHA data."""
    # Create a simple puzzle where user needs to move slider to specific position
    target_position = random.randint(70, 90)  # Target position (70-90% of slider)
    tolerance = 5  # Allow 5% tolerance
    
    return {
        'target_position': target_position,
        'tolerance': tolerance,
        'min_position': target_position - tolerance,
        'max_position': target_position + tolerance
    }



forms

from django import forms
from django.contrib.auth.models import User
from django.core.exceptions import ValidationError
from PIL import Image, ImageDraw, ImageFont
import random
import string
import io
import base64
import re
import logging
from .models import UserProfile

logger = logging.getLogger(__name__)

class RegistrationForm(forms.ModelForm):
    password = forms.CharField(widget=forms.PasswordInput, min_length=8)
    confirm_password = forms.CharField(widget=forms.PasswordInput, label="Confirm Password")
    full_name = forms.CharField(max_length=100, required=True)
    phone = forms.CharField(max_length=20, required=False)
    country = forms.CharField(max_length=50, required=False)
    currency = forms.ChoiceField(choices=UserProfile.CURRENCY_CHOICES, required=False)
    honeypot = forms.CharField(required=False, widget=forms.HiddenInput, label="")
    captcha_answer = forms.CharField(max_length=10, required=True, label="Enter the result shown in the image")

    BLACKLISTED_CHARS = r'[<>{};#&%`~]'

    class Meta:
        model = User
        fields = ['username', 'email', 'password']

    def __init__(self, *args, captcha_answer=None, **kwargs):
        super().__init__(*args, **kwargs)
        self.captcha_answer = captcha_answer
        if self.data:
            logger.debug(f"Registration form POST data: {self.data}")

    def clean_username(self):
        username = self.cleaned_data['username']
        if len(username) > 30:
            raise ValidationError("Username cannot exceed 30 characters.")
        if not re.match(r'^[a-zA-Z0-9_]+$', username):
            raise ValidationError("Username can only contain letters, numbers, and underscores.")
        if re.search(self.BLACKLISTED_CHARS, username):
            raise ValidationError("Username contains invalid characters.")
        if User.objects.filter(username__iexact=username).exists():
            raise ValidationError("This username is already taken.")
        return username

    def clean_email(self):
        email = self.cleaned_data['email']
        if User.objects.filter(email__iexact=email).exists():
            raise ValidationError("This email address is already registered.")
        return email

    def clean_full_name(self):
        full_name = self.cleaned_data['full_name']
        if len(full_name) > 100:
            raise ValidationError("Full name cannot exceed 100 characters.")
        if not re.match(r'^[a-zA-Z\s-]+$', full_name):
            raise ValidationError("Full name can only contain letters, spaces, and hyphens.")
        if re.search(self.BLACKLISTED_CHARS, full_name):
            raise ValidationError("Full name contains invalid characters.")
        return full_name

    def clean_phone(self):
        phone = self.cleaned_data['phone']
        if phone and not re.match(r'^\+?[\d\s-]{7,20}$', phone):
            raise ValidationError("Invalid phone number format.")
        return phone

    def clean_honeypot(self):
        honeypot = self.cleaned_data['honeypot']
        if honeypot:
            raise ValidationError("This field should be empty.")
        return honeypot

    def clean_captcha_answer(self):
        captcha_answer = self.cleaned_data.get('captcha_answer')
        correct_answer = self.captcha_answer
        logger.debug(f"Validating CAPTCHA: entered={captcha_answer}, correct={correct_answer}")
        
        if not captcha_answer or not correct_answer:
            logger.warning(f"Missing CAPTCHA data: entered={captcha_answer}, correct={correct_answer}")
            raise ValidationError("CAPTCHA answer is required.")
        
        entered_clean = str(captcha_answer).strip().lower()
        correct_clean = str(correct_answer).strip().lower()
        
        if entered_clean != correct_clean:
            logger.warning(f"Invalid CAPTCHA answer: entered={entered_clean}, correct={correct_clean}")
            raise ValidationError("Incorrect CAPTCHA answer. Please try again.")
        
        return captcha_answer

    def clean(self):
        cleaned_data = super().clean()
        password = cleaned_data.get('password')
        confirm_password = cleaned_data.get('confirm_password')
        if password and confirm_password and password != confirm_password:
            raise ValidationError("Passwords do not match.")
        return cleaned_data

    def save(self, commit=True):
        user = super().save(commit=False)
        user.set_password(self.cleaned_data['password'])
        user.is_active = True  # Ensure user is active
        if commit:
            try:
                user.save()
                logger.debug(f"User saved in RegistrationForm: username={user.username}, id={user.id}, is_active={user.is_active}")
            except Exception as e:
                logger.error(f"Failed to save user in RegistrationForm: {e}")
                raise
        return user

class LoginForm(forms.Form):
    username = forms.CharField(max_length=30, required=True)
    password = forms.CharField(widget=forms.PasswordInput, required=True)
    honeypot = forms.CharField(required=False, widget=forms.HiddenInput, label="")
    captcha_answer = forms.CharField(max_length=10, required=True, label="Enter the result shown in the image")

    BLACKLISTED_CHARS = r'[<>{};#&%`~]'

    def __init__(self, *args, captcha_answer=None, **kwargs):
        super().__init__(*args, **kwargs)
        self.captcha_answer = captcha_answer
        if self.data:
            logger.debug(f"Login form POST data: {self.data}")

    def clean_username(self):
        username = self.cleaned_data['username']
        if len(username) > 30:
            raise ValidationError("Username cannot exceed 30 characters.")
        if not re.match(r'^[a-zA-Z0-9_]+$', username):
            raise ValidationError("Username can only contain letters, numbers, and underscores.")
        if re.search(self.BLACKLISTED_CHARS, username):
            raise ValidationError("Username contains invalid characters.")
        return username

    def clean_honeypot(self):
        honeypot = self.cleaned_data['honeypot']
        if honeypot:
            raise ValidationError("This field should be empty.")
        return honeypot

    def clean_captcha_answer(self):
        captcha_answer = self.cleaned_data.get('captcha_answer')
        correct_answer = self.captcha_answer
        logger.debug(f"Validating CAPTCHA: entered={captcha_answer}, correct={correct_answer}")
        
        if not captcha_answer or not correct_answer:
            logger.warning(f"Missing CAPTCHA data: entered={captcha_answer}, correct={correct_answer}")
            raise ValidationError("CAPTCHA answer is required.")
        
        entered_clean = str(captcha_answer).strip().lower()
        correct_clean = str(correct_answer).strip().lower()
        
        if entered_clean != correct_clean:
            logger.warning(f"Invalid CAPTCHA answer: entered={entered_clean}, correct={correct_clean}")
            raise ValidationError("Incorrect CAPTCHA answer. Please try again.")
        
        return captcha_answer

class UserProfileForm(forms.ModelForm):
    username = forms.CharField(max_length=150, required=True)
    email = forms.EmailField(required=True)
    
    class Meta:
        model = UserProfile
        fields = ['full_name', 'phone', 'country', 'currency']
    
    def __init__(self, *args, **kwargs):
        self.user = kwargs.pop('user', None)
        super().__init__(*args, **kwargs)
        if self.user:
            self.fields['username'].initial = self.user.username
            self.fields['email'].initial = self.user.email
    
    def clean_username(self):
        username = self.cleaned_data['username']
        if username != self.user.username and User.objects.filter(username__iexact=username).exists():
            raise ValidationError("This username is already taken.")
        return username

    def clean_email(self):
        email = self.cleaned_data['email']
        if email != self.user.email and User.objects.filter(email__iexact=email).exists():
            raise ValidationError("This email address is already registered.")
        return email

    def save(self, commit=True):
        profile = super().save(commit=False)
        if self.user:
            self.user.username = self.cleaned_data['username']
            self.user.email = self.cleaned_data['email']
            if commit:
                try:
                    self.user.save()
                    logger.debug(f"User updated in UserProfileForm: username={self.user.username}, email={self.user.email}")
                except Exception as e:
                    logger.error(f"Failed to save user in UserProfileForm: {e}")
                    raise
        if commit:
            try:
                profile.save()
                logger.debug(f"UserProfile saved in UserProfileForm: user={self.user.username}")
            except Exception as e:
                logger.error(f"Failed to save UserProfile in UserProfileForm: {e}")
                raise
        return profile



{% extends 'base.html' %}
{% block title %}Login - ForexPro{% endblock %}

{% block content %}
<section class="section-elegant min-h-screen flex items-center justify-center">
    <div class="max-w-md w-full mx-auto px-4 sm:px-6 lg:px-8">
        <div class="glass-card form-elegant p-8" data-aos="fade-up">
            <h2 class="text-3xl font-bold mb-6 text-center text-textPrimary">Welcome Back</h2>
            
            {% if messages %}
                {% for message in messages %}
                    <div class="alert mb-4 p-4 rounded-lg glass-card {% if message.tags == 'error' %}border-red-500{% elif message.tags == 'success' %}border-green-500{% else %}border-accent{% endif %} animate-fade-in">
                        <div class="flex items-center">
                            <i class="fas {% if message.tags == 'error' %}fa-exclamation-circle{% elif message.tags == 'success' %}fa-check-circle{% else %}fa-info-circle{% endif %} mr-2 text-textPrimary"></i>
                            <span class="text-textSecondary">{{ message }}</span>
                        </div>
                    </div>
                {% endfor %}
            {% endif %}

            <form method="POST" class="space-y-6" id="loginForm">
                {% csrf_token %}
                {{ form.non_field_errors }}

                <div>
                    <label for="{{ form.username.id_for_label }}" class="block text-sm font-medium text-textSecondary">Username</label>
                    <div class="relative">
                        {{ form.username }}
                        {{ form.username.errors }}
                        <i class="fas fa-user absolute right-3 top-1/2 transform -translate-y-1/2 text-textMuted"></i>
                    </div>
                </div>

                <div>
                    <label for="{{ form.password.id_for_label }}" class="block text-sm font-medium text-textSecondary">Password</label>
                    <div class="relative">
                        {{ form.password }}
                        {{ form.password.errors }}
                        <i class="fas fa-lock absolute right-3 top-1/2 transform -translate-y-1/2 text-textMuted"></i>
                    </div>
                </div>

                <div style="display: none;">
                    {{ form.honeypot }}
                    {{ form.honeypot.errors }}
                </div>

                <!-- Advanced CAPTCHA Section -->
                <div id="captcha-container">
                    {% if captcha_data.type == 'image' %}
                        <div class="captcha-section">
                            <label class="block text-sm font-medium text-textSecondary mb-2">{{ captcha_data.question }}</label>
                            <div class="captcha-image-container mb-3">
                                <img src="{{ captcha_data.image_data }}" alt="CAPTCHA Image" class="captcha-image border rounded">
                            </div>
                            <div class="relative">
                                <input type="text" name="captcha_answer" id="id_captcha_answer" class="form-input" placeholder="Enter the answer" required>
                                <i class="fas fa-puzzle-piece absolute right-3 top-1/2 transform -translate-y-1/2 text-textMuted"></i>
                            </div>
                        </div>
                    {% elif captcha_data.type == 'question' %}
                        <div class="captcha-section">
                            <label for="id_captcha_answer" class="block text-sm font-medium text-textSecondary mb-2">{{ captcha_data.question }}</label>
                            <div class="relative">
                                <input type="text" name="captcha_answer" id="id_captcha_answer" class="form-input" placeholder="Enter your answer" required>
                                <i class="fas fa-question-circle absolute right-3 top-1/2 transform -translate-y-1/2 text-textMuted"></i>
                            </div>
                        </div>
                    {% elif captcha_data.type == 'slider' %}
                        <div class="captcha-section">
                            <label class="block text-sm font-medium text-textSecondary mb-2">{{ captcha_data.question }}</label>
                            <div class="slider-container mb-3">
                                <input type="range" id="captcha-slider" class="slider" min="0" max="100" value="0">
                                <div class="slider-value">Position: <span id="slider-value">0</span>%</div>
                            </div>
                            <input type="hidden" name="captcha_answer" id="id_captcha_answer" value="0">
                        </div>
                    {% endif %}
                    
                    <button type="button" id="refresh-captcha" class="btn-secondary mt-2">
                        <i class="fas fa-refresh mr-1"></i>New CAPTCHA
                    </button>
                </div>

                <button type="submit" class="btn-elegant w-full flex items-center justify-center">
                    <i class="fas fa-sign-in-alt mr-2"></i>Login
                </button>
            </form>

            <p class="mt-4 text-center text-textSecondary">
                <a href="{% url 'main:password_reset' %}" class="text-accent hover:underline">Forgot Password?</a>
            </p>
            <p class="mt-2 text-center text-textSecondary">
                Don't have an account? 
                <a href="{% url 'main:register' %}" class="text-accent hover:underline">Register</a>
            </p>
        </div>
    </div>
</section>

<style>
    .form-elegant input, .form-elegant select, .form-input {
        width: 100%;
        padding: 12px;
        border: 1px solid #ccc;
        border-radius: 6px;
        background-color: rgba(255, 255, 255, 0.1);
        color: #333;
        font-size: 14px;
    }

    @media (prefers-color-scheme: dark) {
        .form-elegant input, .form-elegant select, .form-input {
            color: #ffffff; /* White text for dark mode */
            background-color: rgba(255, 255, 255, 0.15); /* Slightly lighter background for contrast */
            border-color: rgba(255, 255, 255, 0.3); /* Lighter border for visibility */
        }
        .form-elegant input::placeholder, .form-elegant select::placeholder, .form-input::placeholder {
            color: rgba(255, 255, 255, 0.7); /* Light placeholder text for dark mode */
        }
    }
    
    .form-elegant input:focus, .form-elegant select:focus, .form-input:focus {
        outline: none;
        border-color: #007bff;
        box-shadow: 0 0 8px rgba(0, 123, 255, 0.3);
    }
    
    .alert {
        background-color: rgba(255, 255, 255, 0.1);
        border-left: 4px solid;
    }
    
    .btn-elegant {
        padding: 12px 24px;
        background: linear-gradient(135deg, #007bff, #0056b3);
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-weight: 600;
        transition: all 0.3s ease;
    }
    
    .btn-elegant:hover {
        background: linear-gradient(135deg, #0056b3, #004085);
        transform: translateY(-1px);
    }
    
    .btn-secondary {
        padding: 8px 16px;
        background-color: #6c757d;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
    }
    
    .btn-secondary:hover {
        background-color: #545b62;
    }
    
    .captcha-section {
        background-color: rgba(255, 255, 255, 0.05);
        padding: 16px;
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .captcha-image {
        max-width: 100%;
        height: auto;
        background-color: white;
        padding: 8px;
    }
    
    .slider-container {
        padding: 16px 0;
    }
    
    .slider {
        width: 100%;
        height: 6px;
        border-radius: 3px;
        background: #ddd;
        outline: none;
        opacity: 0.7;
        transition: opacity 0.2s;
    }
    
    .slider:hover {
        opacity: 1;
    }
    
    .slider::-webkit-slider-thumb {
        appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #007bff;
        cursor: pointer;
    }
    
    .slider::-moz-range-thumb {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #007bff;
        cursor: pointer;
        border: none;
    }
    
    .slider-value {
        text-align: center;
        margin-top: 8px;
        font-weight: 600;
        color: #007bff;
    }
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
    // Handle slider CAPTCHA
    const slider = document.getElementById('captcha-slider');
    const sliderValue = document.getElementById('slider-value');
    const hiddenInput = document.getElementById('id_captcha_answer');
    
    if (slider) {
        slider.addEventListener('input', function() {
            const value = this.value;
            sliderValue.textContent = value;
            hiddenInput.value = value;
        });
    }
    
    // Handle CAPTCHA refresh
    document.getElementById('refresh-captcha').addEventListener('click', function() {
        const button = this;
        button.disabled = true;
        button.innerHTML = '<i class="fas fa-spinner fa-spin mr-1"></i>Loading...';
        
        fetch('{% url "main:refresh_captcha" %}', {
            method: 'POST',
            headers: {
                'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value,
                'Content-Type': 'application/json',
            },
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                updateCaptchaDisplay(data.captcha_data);
            }
        })
        .catch(error => {
            console.error('Error refreshing CAPTCHA:', error);
        })
        .finally(() => {
            button.disabled = false;
            button.innerHTML = '<i class="fas fa-refresh mr-1"></i>New CAPTCHA';
        });
    });
    
    function updateCaptchaDisplay(captchaData) {
        const container = document.getElementById('captcha-container');
        let html = '';
        
        if (captchaData.type === 'image') {
            html = `
                <div class="captcha-section">
                    <label class="block text-sm font-medium text-textSecondary mb-2">${captchaData.question}</label>
                    <div class="captcha-image-container mb-3">
                        <img src="${captchaData.image_data}" alt="CAPTCHA Image" class="captcha-image border rounded">
                    </div>
                    <div class="relative">
                        <input type="text" name="captcha_answer" id="id_captcha_answer" class="form-input" placeholder="Enter the answer" required>
                        <i class="fas fa-puzzle-piece absolute right-3 top-1/2 transform -translate-y-1/2 text-textMuted"></i>
                    </div>
                </div>
            `;
        } else if (captchaData.type === 'question') {
            html = `
                <div class="captcha-section">
                    <label for="id_captcha_answer" class="block text-sm font-medium text-textSecondary mb-2">${captchaData.question}</label>
                    <div class="relative">
                        <input type="text" name="captcha_answer" id="id_captcha_answer" class="form-input" placeholder="Enter your answer" required>
                        <i class="fas fa-question-circle absolute right-3 top-1/2 transform -translate-y-1/2 text-textMuted"></i>
                    </div>
                </div>
            `;
        } else if (captchaData.type === 'slider') {
            html = `
                <div class="captcha-section">
                    <label class="block text-sm font-medium text-textSecondary mb-2">${captchaData.question}</label>
                    <div class="slider-container mb-3">
                        <input type="range" id="captcha-slider" class="slider" min="0" max="100" value="0">
                        <div class="slider-value">Position: <span id="slider-value">0</span>%</div>
                    </div>
                    <input type="hidden" name="captcha_answer" id="id_captcha_answer" value="0">
                </div>
            `;
        }
        
        html += `
            <button type="button" id="refresh-captcha" class="btn-secondary mt-2">
                <i class="fas fa-refresh mr-1"></i>New CAPTCHA
            </button>
        `;
        
        container.innerHTML = html;
        
        // Re-attach event listeners
        const newSlider = document.getElementById('captcha-slider');
        const newSliderValue = document.getElementById('slider-value');
        const newHiddenInput = document.getElementById('id_captcha_answer');
        
        if (newSlider) {
            newSlider.addEventListener('input', function() {
                const value = this.value;
                newSliderValue.textContent = value;
                newHiddenInput.value = value;
            });
        }
        
        // Re-attach refresh button listener
        document.getElementById('refresh-captcha').addEventListener('click', arguments.callee);
    }
});
</script>
{% endblock %}



i want users to be able tologin with either username or email